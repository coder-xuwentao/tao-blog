export const blogListData = [
  {
    id: 61,
    time_str: '2024-03-19T03:54:30.000Z',
    last_edit_time: '2024-03-19T04:03:14.000Z',
    img_id: null,
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '前端',
    classify_id: '1',
    classify_sub: 'javaScript',
    classify_sub_id: '1_3',
    title: 'JS事件循环机制',
    desc: 'JS事件循环机制',
    content:
      "## JS事件循环机制\n### 区分进程和线程\n下面是一个简单的例子\n\n- 进程是一个工厂，工厂有它的独立资源\n- 工厂之间相互独立\n- 线程是工厂中的工人，多个工人协作完成任务\n- 工厂内有一个或多个工人\n- 工人之间共享空间\n\n与系统联系起来如下\n\n- 工厂的资源 -> 系统分配的内存（独立的一块内存）\n- 工厂之间的相互独立 -> 进程之间相互独立\n- 多个工人协作完成任务 -> 多个线程在进程中协作完成任务\n- 工厂内有一个或多个工人 -> 一个进程由一个或多个线程组成\n- 工人之间共享空间 -> 同一进程下的各个线程之间共享程序的内存空间（包括代码段、数据集、堆等）\n\n用较为官方的术语描述一遍：\n- **进程**是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）\n- **线程**是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）\n\n### 浏览器内核（渲染进程）\n#### GUI渲染线程\n- 当浏览器收到响应的html后，该线程开始解析HTML文档构建DOM树，解析CSS文件构建CSSOM，合并构成渲染树，并计算布局样式，绘制在页面上(该处可深挖的坑，HTML解析规则，CSS解析规则，渲染流程细节)\n- 当界面样式被修改的时候可能会触发reflow（回流）和repaint（重绘），该线程就会重新计算，重新绘制，是前端开发需要着重优化的点（值得注意的是react和vue都使用了[**虚拟DOM**](https://www.jianshu.com/p/271e22c36864)）\n\n#### JS引擎线程\nJS内核，也称JS引擎（例如V8引擎），负责处理执行javascript脚本程序，\n由于js是单线程（一个Tab页内中无论什么时候都只有一个JS线程在运行JS程序），依靠任务队列来进行js代码的执行，所以js引擎会一直等待着任务队列中任务的到来，然后加以处理。\n\n#### 事件触发线程\n归属于渲染（浏览器内核）进程，不受JS引擎线程控制。主要用于控制事件（例如鼠标，键盘等事件），当该事件被触发时候，事件触发线程就会把该事件的处理函数添加进任务队列中，等待JS引擎线程空闲后执行\n\n#### 定时触发器线程\n传说中的setInterval与setTimeout所在线程\n浏览器的定时器并不是由JavaScript引擎计数的，因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响计时的准确，因此通过单独的线程来计时并触发定时器，计时完毕后，满足定时器的触发条件，则将定时器的处理函数添加进任务队列中，等待JS引擎线程空闲后执行。\nW3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms\n\n#### 异步HTTP请求线程\n当XMLHttpRequest连接后，浏览器会新开的一个线程，当监控到readyState状态变更时，如果设置了该状态的回调函数，则将该状态的处理函数推进任务队列中，等待JS引擎线程空闲后执行\n\n>**GUI渲染线程与JS引擎线程是互斥的**，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中**等到JS引擎空闲时**立即被执行。所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。\n\n>浏览器对同一域名请求的并发连接数是有限制的，Chrome和Firefox限制数为6个\n\n![](https://img-1302605407.cos.ap-beijing.myqcloud.com/classify/863e985ded979705a160c0f7519fd09df455196c6d878c314f0a3b0921c89078.png)\n\n#### 浏览器内核中线程之间的关系\n##### 1、GUI渲染线程与JS引擎线程互斥\n由于JavaScript是可操纵DOM的，如果在修改这些元素属性同时渲染界面（即JS线程和UI线程同时运行），那么渲染线程前后获得的元素数据就可能不一致了。\n因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，\nGUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。\n\n##### 2、JS阻塞页面加载\n从上述的互斥关系，可以推导出，JS如果执行时间过长就会阻塞页面。\n譬如，假设JS引擎正在进行巨量的计算，此时就算GUI有更新，也会被保存到队列中，等待JS引擎空闲后执行。\n然后，由于巨量计算，所以JS引擎很可能很久很久后才能空闲，自然会感觉到巨卡无比。\n所以，要尽量避免JS执行时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞的感觉。\n\n##### 3、WebWorker\n[**WebWorker**](https://developer.mozilla.org/zh-CN/docs/Web/API/Web_Workers_API/Using_web_workers)\nweb worker 是运行在后台的 JavaScript，独立于其他脚本，不会影响页面的性能。您可以继续做任何愿意做的事情：点击、选取内容等等，而此时 web worker 在后台运行。\n\n**Web Workers 和 DOM**\n\n由于 web worker 位于外部文件中，它们无法访问下列 JavaScript 对象：\n[window 对象](https://www.w3school.com.cn/jsref/dom_obj_window.asp)\n[document 对象](https://www.w3school.com.cn/jsref/dom_obj_document.asp)\nparent 对象\n\n### 浏览器渲染流程\n提起这个问题不得不引入我们说熟悉的另一个问题，从输入url地址到页面相应都发生了什么？\n\n#### 查询缓存\n[查询缓存](https://www.cnblogs.com/chenlifan/p/13680519.html)\n从输入url按下回车后，我们进入了第一步就是 DNS 解析过程，首先需要找到这个 url 域名的服务器 ip,为了寻找这个 ip，浏览器首先会寻找缓存，查看缓存中是否有记录缓存的查找记录为：浏览器缓存 -> 系统缓存 -> 路由器缓存，缓存中没有则查找系统的 hosts 文件中是否有记录。\n\n#### DNS解析\n如果没有缓存则查询 DNS 服务器，得到服务器的 ip 地址后，浏览器根据这个 ip 以及相应的端口号发送连接请求；如果DNS服务器中没有解析成功，他会向上一步获得的顶级DNS服务器发送解析请求。\n\n#### 建立TCP连接（3次握手）\n服务端新建套接字，绑定地址信息后开始监听，进入LISTEN状态（侦听状态）。客户端新建套接字绑定地址信息后调用connect，发送连接请求SYN，并进入[SYN_SENT](https://baike.baidu.com/item/SYN_SENT)状态，等待服务器的确认。\n服务端一旦监听到连接请求，就会将连接放入内核等待队列中，并向客户端发送SYN和确认报文段ACK，进入[SYN_RECD](https://baike.baidu.com/item/SYN_RECV)状态。\n客户端收到SYN+ACK报文后向服务端发送确认报文段ACK，并进入[ESTABLISHED](https://baike.baidu.com/item/ESTABLISHED)状态，开始读写数据。服务端一旦收到客户端的确认报文，就进入ESTABLISHED状态，就可以进行读写数据了。\n\n#### 客户端发起http请求\nhttp是基于tcp的，所以只有在建立了tcp以后，客户端才能向服务器发起http请求。这个请求报文会包括这次请求的信息，主要是请求方法，请求说明和请求附带的数据，并将这个 http 请求封装在一个 tcp 包中；这个 tcp 包也就是会依次经过传输层，网络层， 数据链路层，物理层到达服务器，服务器解析这个请求来作出响应；返回相应的 html 给浏览器；\n\n#### 服务器处理请求\n后端从在固定的端口接收到TCP报文开始，它会对TCP连接进行处理，对HTTP协议进行解析，并按照报文格式进一步封装成HTTP Request对象，供上层使用。\n\n#### 服务器响应请求\n服务器收到了我们的请求，也处理我们的请求，到这一步，它会把它的处理结果返回，也就是返回一个HTPP响应。\n\n#### 浏览器解析html\n浏览器渲染引擎从网络层取得请求的文档，一般情况下文档会分成 8KB 大小的分块传输。\n浏览器渲染引擎从上往下执行代码（包括HTML,CSS和JS），解析html生成DOM树，同时解析CSS代码生成css rule tree，同时把DOM tree和css rule tree合并生成render tree，同时还会去请求另一些资源，所以渲染引擎会同时干很多事，迫不及待地把内容渲染出来，如果后面的代码会改变之前的样式，会引起回流和重绘。\n**具体渲染流程见下图**\n![](https://img-1302605407.cos.ap-beijing.myqcloud.com/classify/f2716da4fb3c29e8e3d37b0da656dd89c5e6d0382ce6bc1a85b694302ece0b29.png)\n\n#### 断开TCP连接（4次挥手）\n[➡️](https://baike.baidu.com/item/%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B/7794287)\n客户端主动调用close时，向服务端发送结束报文段FIN报，同时进入FIN_WAIT1状态；\n服务器会收到结束报文段FIN报，服务器返回确认报文段ACK并进入CLOSE_WAIT状态，此时如果服务端有数据要发送的话，客户端依然需要接收。客户端收到服务器对结束报文段的确认，就会进入到FIN_WAIT2状态，开始等待服务器的结束报文段；\n服务器端数据发送完毕后，当服务器真正调用close关闭连接时，会向客户端发送结束报文段FIN包，此时服务器进入LAST_ACK状态，等待最后一个ACK的带来；\n客户端收到服务器发来的结束报文段, 进入TIME_WAIT, 并发出送确认报文段ACK；服务器收到了对结束报文段确认的ACK，进入CLOSED状态，断开连接。而客户端要等待2MSL的时间，才会进入到CLOSED状态。\n\n### Event Loop -> JS事件循环机制\nJS分为同步任务和异步任务\n\n同步任务都在主线程上执行，形成一个执行栈\n主线程之外，**事件触发线程**管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。\n一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。\n![](https://img-1302605407.cos.ap-beijing.myqcloud.com/classify/2eca1af1b637d1603cc2d4f8b98867b1d376e4208015e402b1377b96fa9c0f67.png)\n#### 为什么定时器不能准时执行？\nJS是单线程,所以异步事件(比如鼠标点击和定时器)仅在线程空闲时才会被调度运行,代码执行时异步事件任务会按照将它们添加到队列的顺序执行,而setTimeout() 的第二个参数只是告诉JS再过多长时间把当前任务添加到队列中。如果队列是空的,那么添加的代码会立即执行;如果队列不是空的,那么它就要等前面的代码执行完了以后再执行。\n**浏览器不会对同一个setInterval处理程序多次添加到待执行队列。**\n此处可以理解为，当任务队列中已经存在相同id的定时器任务时，后面添加进来的将会被废弃。\n\n>注：一般的话，路由跳转无法销毁setInterval和setTimeout等全局方法（因为它们属于window的方法），所以在使用vue和react native、react等框架时，路由的跳转之前，要清空定时器。\n\n![](https://img-1302605407.cos.ap-beijing.myqcloud.com/classify/2092154f0a089d19ed6811dfb27713402401cb59bf8bd3d1ca555743fca44fa9.png)\n上图大致描述就是：\n主线程运行时会产生执行栈，\n栈中的代码调用某些api时，它们会在事件队列中添加各种事件（当满足触发条件后，如ajax请求完毕）\n而栈中的代码执行完毕，就会读取事件队列中的事件，去执行那些回调\n如此循环\n注意，总是要等待栈中的代码执行完毕后才会去读取事件队列中的事件\n\n```JavaScript\nsetTimeout(function(){\n    console.log('start');\n}, 0);\n\nconsole.log('end');\n```\n\n此处预留一个小问题，以上代码是如何执行的呢？先打印哪个？\n接下来我们开始了解一下，宏任务与微任务。\n#### 宏任务与微任务\n![](https://img-1302605407.cos.ap-beijing.myqcloud.com/classify/3d9cfdfa60e7327199753b9f0ef2b724f146d668a9a3922c81bf85fafcc19b90.png)\n从上图我们可以了解到详细的运行机制：\n\n- 执行一个宏任务（栈中没有就从事件队列中获取）\n执行过程中如果遇到微任务，就将它添加到微任务的任务队列中\n- 宏任务执行完毕后，立即执行当前微任务队列中的所有微任务（依次执行）\n- 当前宏任务执行完毕，开始检查渲染，然后GUI线程接管渲染\n- 渲染完毕后，JS线程继续接管，开始下一个宏任务（从事件队列中获取）\n\n**下面我们来分析几个代码片段的执行结果，看看是否真正掌握了宏任务与微任务的运行机制。**\n\n```JavaScript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('setTimeout');\n}, 0);\n\nPromise.resolve().then(function() {\n  console.log('promise1');\n}).then(function() {\n  console.log('promise2');\n});\n\nconsole.log('script end');\n```\n\n```JavaScript\nconsole.log('script start');\n\nsetTimeout(function() {\n  console.log('timeout1');\n}, 10);\n\nnew Promise(resolve => {\n    console.log('promise1');\n    resolve();\n    setTimeout(() => console.log('timeout2'), 10);\n}).then(function() {\n    console.log('then1')\n})\n\nconsole.log('script end'); \n```\n\n**总结：宏任务与微任务都属于JS的异步任务**\n- **宏任务（macrotask）：**\n异步 Ajax 请求、\nsetTimeout、setInterval、\n文件操作\n其它宏任务\n- **微任务（microtask）：**\nPromise.then、.catch 和 .finally\nprocess.nextTick\n其它微任务\n\n#### 补充：nodeJs中的事件循环  \n[**➡️**](https://www.php.cn/js-tutorial-482726.html)\n**事件驱动程序**\n\n- Node.js 使用事件驱动模型，当web server接收到请求，就把它关闭然后进行处理，然后去服务下一个web请求。\n- 当这个请求完成，它被放回处理队列，当到达队列开头，这个结果被返回给用户。\n- 这个模型非常高效可扩展性非常强，因为 webserver 一直接受请求而不等待任何读写操作。（这也称之为非阻塞式IO或者事件驱动IO）\n- 在事件驱动模型中，会生成一个主循环来监听事件，当检测到事件时触发回调函数。\n![](https://img-1302605407.cos.ap-beijing.myqcloud.com/classify/080f1bdfd41fb22e973eb874aa20b685401ce74ab82ecf231332fc291d8493a4.png)\n整个事件驱动的流程就是这么实现的，非常简洁。有点类似于观察者模式，事件相当于一个主题(Subject)，而所有注册到这个事件上的处理函数相当于观察者(Observer)。\n",
    storage_type: '1',
    selected: 1,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 306,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
  {
    id: 43,
    time_str: '2022-11-16T10:18:40.000Z',
    last_edit_time: '2023-09-07T09:12:35.000Z',
    img_id: '093b312fbc356b145113427b3eb219024be46ef77d879ad5df1ae2efc60f77c3',
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '其它学习资料',
    classify_id: '3',
    classify_sub: 'git',
    classify_sub_id: '3_2',
    title: 'git代码提交规范',
    desc: 'git代码提交规范',
    content:
      '## 格式： type(scope) : subject<br />\n(1) type（必须）: commit 的类别，只允许使用下面几个标识：<br />\n① feat：提交新功能<br />\n② fix：修复了bug<br />\n③ docs：只修改了文档<br />\n④ style：调整代码格式，未修改代码逻辑（比如修改空格、格式化、缺少分号等）<br />\n⑤ refactor：代码重构，既没修复bug也没有添加新功能<br />\n⑥ perf：性能优化，提高性能的代码更改<br />\n⑦ test：添加或修改代码测试<br />\n⑧ revert: 撤销上一次的commit<br />\n⑨ build: 改变了build工具, 如 grunt换成了 npm<br />\n⑩ chore：对构建流程或辅助工具和依赖库（如文档生成等）的更改，如：webpack 升级等<br />\ndb: 数据升级脚本版本号（包括新增表，修改表字段等操作，需要单独分支独立处理，然后PR到提交主分支）<br />\n\n(2) scope（可选）: 用于说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同<br />\n(3) subject（必须）: commit 的简短描述，不超过50个字符（推荐以动词开头，如： 设置、修改、增加、删减、撤销等）',
    storage_type: '1',
    selected: 1,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 981,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
  {
    id: 25,
    time_str: '2022-07-13T10:14:05.000Z',
    last_edit_time: '2023-07-05T10:19:39.000Z',
    img_id: null,
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '前端',
    classify_id: '1',
    classify_sub: '其它',
    classify_sub_id: '1_16',
    title: 'MDX、markdown基本语法',
    desc: '了解本篇文章，可以更方便的使用markdown语法来编辑博文。',
    content:
      '## [MDX官网](https://www.mdxjs.cn/)\n## 代码块显示效果\n```markdown\n### 代码块显示效果\n注：markdown对代码块的语法是开始和结束行都要添加：\\`\\`\\`,其中 \\` 为windows键盘左上角那个，如下：\n```\n\n``` java\npublic class MyActivity extends AppCompatActivity {\n@Override  //override the function\n    protected void onCreate(@Nullable Bundle savedInstanceState) {\n       super.onCreate(savedInstanceState);\n       try {\n            OkhttpManager.getInstance().setTrustrCertificates(getAssets().open("mycer.cer");\n            OkHttpClient mOkhttpClient= OkhttpManager.getInstance().build();\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n}\n```\n要精确指定语言（如：`java,cpp,css,xml,javascript,python,php,go,kotlin,lua,objectivec`等等）时，在头部直接指定，如：\\`\\`\\`javascript，如下：\n\n``` javascript\nfunction DisplayWindowSize(){\n\n  var w=window.innerWidth\n  || document.documentElement.clientWidth\n  || document.body.clientWidth;\n}\n``` \n\n## 图片显示\n```markdown\n### 图片显示\n\n下面的是公众号二维码图片，欢迎关注。\n![图注:BioIT爱好者公众号](https://apps-db.oss-cn-shenzhen.aliyuncs.com/bioitee/bioitee.png) \n\n注：markdown对图片链接的语法是:`![]()`,\n\n如：`![这里写图片描述](https://apps-db.oss-cn-shenzhen.aliyuncs.com/bioitee/bioitee.png)`,\n可直接把网络图片地址添加到markdown中，\n\n默认为图片居中，如果想居左时，请打开"一键排版"下的css样式中的`img{margin:0 0;}`,\n\n`[这里写图片描述]`中对图片的描述内容会自动生成在图片的底部，对应样式`figcaption{}`\n```\n\n## 云图床功能\n```markdown\n### 云图床功能\nMd2All支持云图床，设置好云图床后，能把本地图片自动上传到云图床，并自动生成markdown.\n\n[请参考云图床教程:https://www.cnblogs.com/garyyan/p/9181809.html](https://www.cnblogs.com/garyyan/p/9181809.html)\n```\n\n## Latex数学公式(能正确复制到公众号等平台）\n```markdown\n### Latex数学公式(能正确复制到公众号等平台）:\n“复制”时会自动把Latex数学公式转换为图片，并自动上传到云图床（如果在“图片”设置了“...,自动上传到云图床”）。\n[请参考：Md2All,让公众号完美显示Latex数学公式](https://www.cnblogs.com/garyyan/p/9228994.html)\n#### 行内公式：$...$\n是的，我就是行内公式：$e^{x^2}\\neq{e^x}^2$，排得OK吗？\n\n#### 块公式：$$...$$\n$$e^{x^2}\\neq{e^x}^2$$\n\n来个 *"复杂点"* 的:\n$$H(D_2) = -(\\frac{2}{4}\\ log_2 \\frac{2}{4} + \\frac{2}{4}\\ log_2 \\frac{2}{4}) = 1$$\n\n矩阵：\n$$\n        \\begin{pmatrix}\n        1 & a_1 & a_1^2 & \\cdots & a_1^n \\\\\n        1 & a_2 & a_2^2 & \\cdots & a_2^n \\\\\n        \\vdots & \\vdots & \\vdots & \\ddots & \\vdots \\\\\n        1 & a_m & a_m^2 & \\cdots & a_m^n \\\\\n        \\end{pmatrix}\n$$\n\n对应“一键排版”的css样式关键字为：`.katex`\n\n#### Latex复制到公众号等各平台的特别说明\n\n##### 复杂的行内公式（顶部和底部突出很多那种），转换后，如果显示不完整，请改为块公式\n有些比较复杂的行内公式,转换后，可能会出现顶部和底部很突出的部分看不见的情况，把它改成块公式就OK。\n\n##### 公众号报”图片粘贴失败“时，配合云图床完美解决\n如果你发现复制到公众号时报**”图片粘贴失败“**，那是因为公众号有个很奇怪的问题：当复制很小很小的本地图片时，就可能会报”图片粘贴失败“，而其它的平台暂时没遇到。\n解决的办法是点“图片”图标，设置好图床信息，并选“...,自动上传到云图床”。\n[请参考云图床教程:https://www.cnblogs.com/garyyan/p/9181809.html](https://www.cnblogs.com/garyyan/p/9181809.html)\n\n##### 针对“知乎”的解决方法\n知乎是一个比较神奇的网站，会把你的所有的样式恢复为默认的，并图片一定是居中的，也不能直接复制本地的图片。\n所以你如果想要在知乎上正常显示：\n1:只用块公式，或你可以接受行内公式在知乎上显示变成了块公式;\n2:设置云图床，参考上面公众号那样设置“图片”->“...,自动上传到云图床”。\n\n```\n\n\n## Markdown基本语法\n```markdown\n### Markdown基本语法\n\n\n#### 标题\n支持6种大小的标题，分别对应`#`,`##`,`###`,`####`,`#####`,`######`，和样式文件中的`h1,...,h6`如：\n\n##### H5\n###### H6\n#### 行内代码\n如：`AppCompatActivity`类,markdown对行内代码的语法是前后用：\\`,其中 \\` 为windows键盘左上角那个,\n\n#### 强调\n**我是强调**\n\n#### 斜体\n试试*斜体*\n\n#### 强调的斜体\n试试***强调的斜体***\n\n#### 删除\n试试 ~~删除~~\n\n#### 外链的超链接\n试试外链的超链接：[我是外链的超链接](https://blog.csdn.net/gary_yan/article/details/78645303),markdown对链接的语法为：`[]()`,如：`[我是外链的超链接](https://blog.csdn.net/gary_yan/article/details/78645303)`\n\n#### 页内的超链接\n试试页内的超链接：[我是页内的超链接](#jump_1)，注：你先要在要跳转的到地方放置一个类似：`<a id="jump_1">任意内容</a>`的锚点。由`id="jump_1" `来匹配。\n\n#### 有序列表\n1. 有序列表 1\n2. 有序列表 2\n3. 有序列表 3\n\n#### 无序列表\n- 无序列表 1\n- 无序列表 2 \n- 无序列表 3\n\n#### 引用块\n只需要在前面加 `>`,如下:\n>我是引用块\n微信公众号：颜家大少\n欢迎关注我，一起学习，一起进步!\n\n#### 分隔线\n***\n\n\n### Markdown扩展语法\n\n#### 表格 \n| 班级 | 男生 | 女生 |\n|-----|-----|------|\n| 一(7)班 | 30   | 25 |\n| 一(8)班 | 25   | 30 |\n\n注：表格在公众号预览时，可能在PC端显示的不是正确的全屏，但在手机上预览时就会正常显示为全屏的了。\n\n####任务列表\n- [x] 任务1，已完成;\n- [x] 任务2，已完成;\n- [ ] 任务3，未完成; \n\n#### 注脚\n我是注脚[^10]。点点就能知到我跳到了那儿。\n或跳到放置：`<a id="footnote-10">任意内容</a>`的地方,[^10] 对应`id="footnote-10"`\n\n\n#### TOC\n看内容目录就是用`[toc]`生成的\n注：只要放置:`[TOC]`,就能把其后面的标题如：`#,##,...######`自动生成目录树，注意，`[TOC]`要独立一行，并前面和后面都要空一行\n\n\n### 直接支持html,css\n如果你懂html和css，那下面这些效果就不在话下了：\n\n<a href="#jump_1">来个页内跳转</a>，跳转到文未的：`<a id="jump_1">我是页内跳转到的位置</a>` ,对应：`id="jump_1"`\n<span  style="color: #5bdaed; ">先给点颜色你看看</span>\n<span  style="color: #AE87FA; ">再给点颜色你看看</span> \n<span  style="font-size:1.3em;">试试改变字体大小</span>\n<span  style="font-size:1.3em;font-weight: bold;">改变字体大小，再来个粗体又如何？</span>\n\n<p style="text-align:center">\n试试内容居中\n</p>\n\n<p style="text-align:right">\n那内容居右呢？\n</p>\n\n<p style="text-align:center;color:#1e819e;font-size:1.3em;font-weight: bold;">\n来个综合的试试\n<br/>\n第二行\n</p>\n\n请参考"一键排版"中的"标题首字突出"样式的提示修改,可把此标题首字突出:\n### <span class="firstletter">1</span>试试首字突出\n\n```\n',
    storage_type: '1',
    selected: 1,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 1095,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
  {
    id: 60,
    time_str: '2023-09-25T10:27:34.000Z',
    last_edit_time: '2023-12-22T07:19:24.000Z',
    img_id: null,
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '前端',
    classify_id: '1',
    classify_sub: '其它',
    classify_sub_id: '1_16',
    title: 'fetch二次封装',
    desc: '每次新建项目都需要对请求进行封装，但是每个项目封装的方式都不一样，而且之前都是基于axios的二次封装，以下是我对fetch的二次封装，用作新建项目的基建api。',
    content:
      '### fetch二次封装\n\n每次新建项目都需要对请求进行封装，但是每个项目封装的方式都不一样，而且之前都是基于axios的二次封装，以下是我对fetch的二次封装，用作新建项目的基建api。\n\n```javascript\ntype FetchType = {\n  url: string;\n  method: keyof typeof HttpMethod; // HTTP请求方法类型\n  data?: any; // 请求数据\n  contentType?: keyof typeof ContentType; // 请求内容类型\n  headers?: HeadersInit; // 请求头\n  config?: RequestInit; // fetch配置项\n  timeout?: number; // 请求超时时间\n};\n\nconst initConfig: any = {\n  env: process.env.NODE_ENV || "development", // 环境变量\n  baseUrlObj: {\n    development: "", // 开发环境的基础URL\n    production: "", // 生产环境的基础URL\n  },\n  contentType: "JSON", // 默认的请求内容类型\n  timeout: 5000, // 默认的请求超时时间\n};\n\n// 定义ContentType的enum\nexport const ContentType = {\n  JSON: "application/json",\n  FORM: "application/x-www-form-urlencoded",\n  TEXT: "text/plain",\n  BLOB: "application/octet-stream",\n  ARRAYBUFFER: "application/octet-stream",\n};\n\n// 定义method的enum\nconst HttpMethod = {\n  GET: "GET",\n  POST: "POST",\n  PUT: "PUT",\n  DELETE: "DELETE",\n};\n\nfunction fetchRequest({\n  url,\n  method,\n  data,\n  contentType = initConfig.contentType,\n  headers,\n  config,\n  timeout = initConfig.timeout,\n}: FetchType) {\n  let options: { [key: string]: any } = {\n    method,\n    headers: {\n      "Content-Type": ContentType[contentType], // 设置请求头的Content-Type\n      ...headers,\n    },\n    mode: "cors",\n    // 其他fetch配置项\n    ...config,\n  };\n\n  if (!/^http(s?):\\/\\//i.test(url)) {\n    url = (initConfig.baseUrlObj[initConfig.env] || "") + url; // 拼接完整的请求URL\n  }\n\n  if (method !== "GET" && data) {\n    options.body =\n      contentType === "JSON" ? JSON.stringify(data) : new URLSearchParams(data); // 根据请求内容类型设置请求体数据\n  }\n\n  // 发送请求前调用请求拦截器\n  if (fetchRequest.requestInterceptor) {\n    options = fetchRequest.requestInterceptor(options);\n  }\n\n  let cancel;\n\n  // 取消请求配置\n  const cancelToken = new Promise((resolve) => {\n    cancel = () => resolve({ code: "END", msg: "Request termination" });\n  });\n\n  // 超时配置\n  const timeoutPromise = new Promise((_resolve, reject) => {\n    setTimeout(() => {\n      reject({\n        code: "ERROR",\n        msg: "请求超时",\n      });\n    }, timeout);\n  });\n\n  // 真实请求配置\n  const requestPromise = new Promise((resolve, reject) => {\n    fetch(url, options)\n      .then((response) => {\n        let newResponse;\n        // 处理响应前调用响应拦截器\n        if (fetchRequest.responseInterceptor) {\n          newResponse = fetchRequest.responseInterceptor(response, contentType);\n        }\n        resolve(newResponse);\n      })\n      .catch((error) => {\n        // 处理错误前调用错误处理函数\n        if (fetchRequest.errorHandler) {\n          fetchRequest.errorHandler(error);\n        }\n        reject(error);\n      });\n  });\n\n  // 返回一个包含请求和取消函数的对象\n  return {\n    request: Promise.race([cancelToken, timeoutPromise, requestPromise]),\n    cancel,\n  };\n}\n\n// 自定义请求拦截器\nfetchRequest.requestInterceptor = async (options: any) => {\n  const { method, data, contentType } = options;\n\n  // 在这里可以对请求config进行处理，比如添加token等\n  if (method !== "GET" && data && contentType === "FORM") {\n    // 序列化表单数据\n    const formData: any = new URLSearchParams();\n    Object.entries(data).forEach(([key, value]) => {\n      formData.append(key, value);\n    });\n\n    // 更新请求体和请求头的配置\n    options.body = formData;\n  }\n\n  return options;\n};\n\n// 自定义响应拦截器\nfetchRequest.responseInterceptor = async (\n  response: any,\n  contentType: keyof typeof ContentType\n) => {\n  // 在这里可以对响应response进行处理，比如处理错误码等\n  let { status, statusText } = response;\n  if (status >= 200 && status < 400) {\n    let result;\n    switch (contentType) {\n      case "JSON":\n        result = response.json();\n        break;\n      case "TEXT":\n        result = response.text();\n        break;\n      case "BLOB":\n        result = response.blob();\n        break;\n      case "ARRAYBUFFER":\n        result = response.arrayBuffer();\n        break;\n      case "FORM": // 添加对 FORM 类型的处理\n        result = response.formData();\n        break;\n      default:\n        result = response;\n    }\n    return result;\n  }\n  return {\n    code: "STATUS ERROR",\n    status,\n    statusText,\n  };\n};\n\n// 自定义错误处理函数\nfetchRequest.errorHandler = function (error: any) {\n  // 在这里可以对错误进行处理，比如弹窗提示等\n  console.log("请求发生错误:", error);\n};\n\n/* ———— 以下对不同请求又加了一层封装 —————————————————————————————————————————————————————————————— */\n\ntype Options = {\n  isCancel?: boolean;\n  config?: RequestInit;\n  headers?: HeadersInit;\n  contentType?: keyof typeof ContentType;\n  data?: any;\n};\n\ntype GetFunction = (url: string, options?: Options) => Promise<any>;\ntype PostFunction = (url: string, options?: Options) => Promise<any>;\ntype PutFunction = (url: string, options?: Options) => Promise<any>;\ntype DeleteFunction = (url: string, options?: Options) => Promise<any>;\n\nexport const get: GetFunction = async (url: string, options: Options = {}) => {\n  if (options.isCancel) {\n    return fetchRequest({ url, method: "GET", ...options }); // 根据选项是否取消请求来调用fetchRequest\n  }\n  const fetchObj = fetchRequest({ url, method: "GET" });\n  return new Promise((resolve, reject) => {\n    fetchObj.request.then(resolve).catch(reject);\n  });\n};\n\nexport const post: PostFunction = async (\n  url: string,\n  options: Options = {}\n) => {\n  if (options.isCancel) {\n    return fetchRequest({ url, method: "POST", ...options });\n  }\n  const fetchObj = fetchRequest({ url, method: "POST", ...options });\n  return new Promise((resolve, reject) => {\n    fetchObj.request.then(resolve).catch(reject);\n  });\n};\n\nexport const put: PutFunction = async (url: string, options: Options = {}) => {\n  if (options.isCancel) {\n    return fetchRequest({ url, method: "PUT", ...options });\n  }\n  const fetchObj = fetchRequest({ url, method: "PUT", ...options });\n  return new Promise((resolve, reject) => {\n    fetchObj.request.then(resolve).catch(reject);\n  });\n};\n\nexport const del: DeleteFunction = async (\n  url: string,\n  options: Options = {}\n) => {\n  if (options.isCancel) {\n    return fetchRequest({ url, method: "DELETE", ...options });\n  }\n  const fetchObj = fetchRequest({ url, method: "DELETE", ...options });\n  return new Promise((resolve, reject) => {\n    fetchObj.request.then(resolve).catch(reject);\n  });\n};\n\n```\n### 结尾\n> 原文链接 https://wp-boke.work/blog-details/60',
    storage_type: '1',
    selected: 0,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 728,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
  {
    id: 59,
    time_str: '2023-08-18T08:56:31.000Z',
    last_edit_time: '2023-12-25T10:11:42.000Z',
    img_id: '',
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '前端',
    classify_id: '1',
    classify_sub: 'vue3',
    classify_sub_id: '1_4',
    title: '如何在vue3中使用markdown-it解析markdown',
    desc: '如何使用markdown-it在vue3中配置markdown渲染插件\n1. 新建一个 RenderMarkdown.vue 组件\n2.安装npm包\n3.配置 markdown-it 解析\n...',
    content:
      "### 新建一个 RenderMarkdown.vue 组件\n用于渲染 markdown 内容\n```html\n<template>\n    <span v-html=\"markdownDom\"></span>\n</template>\n```\n\n### 安装npm包\n\n```bash\npnpm i markdown-it markdown-it-highlightjs markdown-it-code-copy\n```\n\n### 配置 markdown-it 解析\n\n```javascript\nimport { watchEffect, ref } from 'vue'\nimport MarkdownIt from 'markdown-it'\nimport markdownItHighlightjs from 'markdown-it-highlightjs'\nimport markdownItCodeCopy from 'markdown-it-code-copy'\n\nconst props = defineProps<{\n    markdownText: string\n}>()\n\n// 用于存放最终解析出来的dom\nconst markdownDom = ref<any>('')\n\n// 初始化 markdown-it 实例\nconst md = new MarkdownIt()\n// 配置代码高亮插件\nmd.use(markdownItHighlightjs)\n// 配置代码块复制插件\nmd.use(markdownItCodeCopy)\n\n// 解析markdown\nconst handleMarkdown = () => {\n    // 判断markdown为空不解析\n    if (!props.markdownText) {\n        return\n    }\n\n    // 解析markdown获取HTML\n    const html = md.render(props.markdownText)\n\n    markdownDom.value = html\n}\n\nwatchEffect(() => {\n    handleMarkdown()\n})\n```\n### 引入样式\n1. 安装 highlightjs\n2. 在全局css内引入\n```css\n@import url(highlightjs/styles/default.css);\n```\n\n### 结尾\n>原文链接 https://wp-boke.work/blog-details/59",
    storage_type: '1',
    selected: 0,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 1118,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
  {
    id: 57,
    time_str: '2023-06-13T10:58:09.000Z',
    last_edit_time: '2023-06-13T10:58:09.000Z',
    img_id: '',
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '前端',
    classify_id: '1',
    classify_sub: 'react',
    classify_sub_id: '1_5',
    title: '基于react万能的虚拟滚动解决方案',
    desc: '万能的虚拟滚动解决方案，基于react，适用场景广泛，\n1. 虚拟列表项高度不固定；\n2. 页面是自适应，导致列表项高度会产生变动；\n3. 列表存在滚动加载的场景；\nemmmm，我觉得万能，哈哈哈',
    content:
      '> 看了很多虚拟滚动的文章，各种解决办法，但我都觉得和自己心目中的虚拟滚动有些差距，于是在风和日丽的下午，自己动手实现一个组件级别的虚拟滚动。\n\n### 组件适用场景\n1. 虚拟列表项高度不固定；\n2. 页面是自适应，导致列表项高度会产生变动；\n3. 列表存在滚动加载的场景；\n\n### 组件实现\n首先我们需要考虑以下几点：\n1. 虚拟滚动的判断条件\n    \n    也就是在什么时候不渲染内部元素，在什么时候开始渲染内部元素，我首先考虑到的就是元素是否在视口可见。当元素在视口可见时，需要渲染内部元素，反之则不渲染，这里我们可以使用**getBoundingClientRect**，**getBoundingClientRect**是一个JavaScript方法，它返回一个包含当前元素相对于视口的位置和大小的DOMRect对象。我们可以通过判断它的top和bottom，监控当前列表项是否渲染。\n    \n2. 在初始化没有确定高度的时候如何处理\n\n\n    我这里的解决方案是，初始化全部渲染，因为我是滚动加载，不需要考虑首次渲染卡顿问题，其他同学如果是一次性渲染，可以为组件添加默认值，默认前几个初始化渲染，让列表初始化有内容，后面的就可以由组件控制渲染了。\n    \n3. 需要考虑视口大小变化的时候列表项高度变化的处理\n\n    这里的解决办法是监听窗口大小变化，重置高度为auto，并且强制刷新。\n    \n### 代码实现\n```javascript\nimport React, { useEffect, useRef, useState } from "react";\nimport { useUpdate } from "ahooks";\nimport { bindHandleScroll, removeScroll } from "@/utils/elementUtils";\nimport style from "./virtuallyItem.module.css";\n\nconst VirtuallyItem = (props) => {\n  const update = useUpdate();\n  // 用于记录当前元素的高度\n  const itemHeight = useRef<number | null>(null);\n  // 用户保存当前的元素\n  const item = useRef<any>(null);\n  // 判断当前元素是否在可视窗口\n  const [isVisual, setIsVisual] = useState<boolean>(true);\n\n  const scrollCallback = () => {\n    // get position relative to viewport\n    const rect = item.current?.getBoundingClientRect();\n    const distanceFromTop = rect.top;\n    const distanceFromBottom = rect.bottom;\n    // 可视区域高度\n    const viewportHeight =\n      window.innerHeight || document.documentElement.clientHeight;\n    if (\n      (distanceFromTop > -200 && distanceFromTop < viewportHeight + 200) ||\n      (distanceFromBottom > -200 && distanceFromBottom < viewportHeight + 200)\n    ) {\n      setIsVisual(true);\n    } else {\n      setIsVisual(false);\n    }\n  };\n\n  const windowResize = () => {\n    itemHeight.current = null;\n    update();\n  };\n\n  useEffect(() => {\n    bindHandleScroll(scrollCallback);\n    window.addEventListener("resize", windowResize);\n\n    return () => {\n      removeScroll(scrollCallback);\n      window.removeEventListener("resize", windowResize);\n    };\n  }, []);\n\n  useEffect(() => {\n    if (item.current && itemHeight.current !== item.current?.offsetHeight) {\n      itemHeight.current = item.current?.offsetHeight;\n    }\n  }, [item.current, isVisual]);\n\n  return (\n    <div\n      className={style.virtually_item}\n      ref={item}\n      style={{\n        height: `${itemHeight.current ? `${itemHeight.current}px` : "auto"}`,\n      }}\n    >\n      {isVisual && props.children}\n    </div>\n  );\n};\n\nexport default VirtuallyItem;\n```\n> bindHandleScroll是绑定滚动事件 removeScroll是移除滚动事件\n\n在列表中使用\n```javascript\nimport React, { useEffect, useRef, useState } from "react";\nimport VirtuallyItem from "@/components/VirtuallyItem";\n\nconst ListBox = () => {\n    const list = [.....];\n    \n    return <div>\n        {list?.map(item => (\n            <VirtuallyItem>\n                {/* 原列表项dom */}\n            </VirtuallyItem>\n        )}\n    </div>\n}\n\nexport default ListBox;\n```\n### 结尾\n以上就是我的简单实现啦，亲测还可以，目前用在我的博客[ shimmer ](https://wp-boke.work/tree-hole)\n欢迎大家批评指正。',
    storage_type: '1',
    selected: 0,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 901,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
  {
    id: 56,
    time_str: '2023-06-01T04:04:03.000Z',
    last_edit_time: '2024-01-03T03:53:41.000Z',
    img_id: '',
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '前端',
    classify_id: '1',
    classify_sub: '其它',
    classify_sub_id: '1_16',
    title: '一次chatgpt解决问题的记录',
    desc: '一次chatgpt解决问题的记录',
    content:
      '### Q: 解析这段数据\n\n```json\n{\n    "idToState": {\n        "168558974908509674243174671016": {\n            "normalized": true,\n            "title": "",\n            "url": "https://dribbble.com/shots/21614035-Community",\n            "hash": "/shots/21614035-Community",\n            "data": {},\n            "id": "168558974908509674243174671016",\n            "cleanUrl": "https://dribbble.com/shots/21614035-Community",\n            "hashedUrl": "https://dribbble.com/shots/21614035-Community"\n        },\n        "168558978059406754094829987627": {\n            "normalized": true,\n            "title": "",\n            "url": "https://dribbble.com/",\n            "hash": "/",\n            "data": {},\n            "id": "168558978059406754094829987627",\n            "cleanUrl": "https://dribbble.com/",\n            "hashedUrl": "https://dribbble.com/"\n        },\n        "168558981552607379599834810859": {\n            "normalized": true,\n            "title": "",\n            "url": "https://dribbble.com/shots/21613107-A-New-Song",\n            "hash": "/shots/21613107-A-New-Song?&_suid=168558981552607379599834810859",\n            "data": {\n                "steps-from-list": 1,\n                "disable-nav": false\n            },\n            "id": "168558981552607379599834810859",\n            "cleanUrl": "https://dribbble.com/shots/21613107-A-New-Song",\n            "hashedUrl": "https://dribbble.com/shots/21613107-A-New-Song?&_suid=168558981552607379599834810859"\n        },\n        "168558983073303266180961660783": {\n            "normalized": true,\n            "title": "",\n            "url": "https://dribbble.com/shots/21614035-Community",\n            "hash": "/shots/21614035-Community?&_suid=168558983073303266180961660783",\n            "data": {\n                "steps-from-list": 1,\n                "disable-nav": false\n            },\n            "id": "168558983073303266180961660783",\n            "cleanUrl": "https://dribbble.com/shots/21614035-Community",\n            "hashedUrl": "https://dribbble.com/shots/21614035-Community?&_suid=168558983073303266180961660783"\n        }\n    },\n    "urlToId": {\n        "https://dribbble.com/": "168558978059406754094829987627",\n        "https://dribbble.com/shots/21614035-Community": "168558983073303266180961660783",\n        "https://dribbble.com/shots/21613107-A-New-Song": "168558981552607379599834810859"\n    },\n    "stateToId": {\n        "{\\"data\\":{},\\"title\\":\\"\\",\\"url\\":\\"https://dribbble.com/shots/21614035-Community\\"}": "168558974908509674243174671016",\n        "{\\"data\\":{},\\"title\\":\\"\\",\\"url\\":\\"https://dribbble.com/\\"}": "168558978059406754094829987627",\n        "{\\"data\\":{\\"steps-from-list\\":1,\\"disable-nav\\":false},\\"title\\":\\"\\",\\"url\\":\\"https://dribbble.com/shots/21613107-A-New-Song\\"}": "168558981552607379599834810859",\n        "{\\"data\\":{\\"steps-from-list\\":1,\\"disable-nav\\":false},\\"title\\":\\"\\",\\"url\\":\\"https://dribbble.com/shots/21614035-Community\\"}": "168558983073303266180961660783"\n    }\n}\n```\n\n### A: 这似乎是一个 `History.store` 对象的示例，其中包含三个主要属性 `idToState`、`urlToId` 和 `stateToId`。\n\n- `idToState`：将字符串 ID 映射到历史状态对象，包含 normalized、title、url、hash、data、id、cleanUrl 和 hashedUrl 信息。\n\n- `urlToId`：将 URL 映射到字符串 ID，以便在重新加载页面时检索历史状态对象。\n\n- `stateToId`：将历史状态对象的 JSON 串映射到字符串 ID，以便在重新加载页面时检索历史状态对象。\n\n这个对象可以被用来管理 `History` API 在多页应用中的状态。例如，在用户浏览应用程序时，可以使用这个对象将当前的历史状态对象映射到相应的 URL，使得当用户点击浏览器的前进和后退按钮时可以正确地恢复应用程序到相应的历史状态。\n\n\n### Q: 具体如何实现\n\n### A: 实现 `History.store` 对象需要在应用程序中记录历史状态对象，并在页面转换和跳转时更新相应的映射表。以下是一个示例实现方法：\n\n```javascript\nconst History = {\n  // 存储历史状态对象的映射表\n  store: {\n    idToState: {},\n    urlToId: {},\n    stateToId: {},\n  },\n\n  // 添加历史状态对象到映射表中\n  addState: function (stateObj, url) {\n    if (!stateObj.url) {\n      stateObj.url = url;\n    }\n\n    const stateId =\n      (+new Date()).toString(16) +\n      Math.floor(Math.random() * 1000000).toString(16);\n    const stateData = {\n      id: stateId,\n      url: stateObj.url,\n      data: stateObj.data || {},\n      title: stateObj.title || document.title,\n      normalized: true,\n      cleanUrl: cleanUrl(stateObj.url),\n      hashedUrl: stateObj.url,\n    };\n\n    this.store.idToState[stateId] = stateData;\n    this.store.urlToId[stateData.cleanUrl] = stateId;\n    this.store.stateToId[JSON.stringify(stateData)] = stateId;\n\n    return stateData;\n  },\n\n  // 获取上一个历史状态对象\n  getPrevState: function () {\n    const currentState = this.getCurrentState();\n    const prevStateId = this.store.idToState[currentState.id].previousId;\n    if (prevStateId) {\n      return this.store.idToState[prevStateId];\n    }\n    return null;\n  },\n\n  // 获取当前的历史状态对象\n  getCurrentState: function () {\n    const currentStateId = window.history.state\n      ? window.history.state.id\n      : null;\n    if (currentStateId) {\n      return this.store.idToState[currentStateId];\n    } else if (\n      window.location.href !==\n      this.store.idToState[this.store.currentStateId].url\n    ) {\n      return this.addState(\n        {\n          url: window.location.href,\n        },\n        document.title\n      );\n    } else {\n      return this.store.idToState[this.store.currentStateId] || null;\n    }\n  },\n\n  // 更新历史状态对象\n  updateState: function (stateObj, replace) {\n    const currentState = this.getCurrentState();\n    const newState = this.addState(stateObj);\n\n    if (replace) {\n      window.history.replaceState(newState, newState.title || "");\n    } else {\n      window.history.pushState(newState, newState.title || "");\n      this.store.idToState[newState.id].previousId = currentState.id;\n    }\n\n    return newState;\n  },\n\n  // 根据 URL 获取历史状态对象\n  getStateByUrl: function (url) {\n    const stateId = this.store.urlToId[cleanUrl(url)];\n    if (stateId) {\n      return this.store.idToState[stateId];\n    }\n    return null;\n  },\n};\n\n// 去除 URL 中的查询参数和哈希值，获取干净的 URL\nfunction cleanUrl(url) {\n  const cleanUrl = url.split(/[?#]/)[0];\n  return cleanUrl;\n}\n```\n\n在这个示例中，我们创建了一个全局的 `History` 对象，它拥有 `store` 属性、`addState()`、`getPrevState()`、`getCurrentState()`、`updateState()` 和 `getStateByUrl()` 等方法。在这些方法中，我们使用 `idToState`、`urlToId` 和 `stateToId` 映射表来记录历史状态对象，并相应地更新它们。此外，我们还使用 `cleanUrl()` 方法将 URL 中的查询参数和哈希值去除，获取干净的 URL。\n\n您可以根据需要加入更多的方法来支持您的应用程序的需求。请注意，这是一个粗略的示例实现，需要在应用程序中进行相应的调整和测试。\n\n### Q：如何使用这个对象\n\n### A：使用 `History` 对象来管理您的应用程序的历史状态对象需要在页面中相应地调用它的方法。以下是一个简单的示例，演示如何在应用程序中使用 `History` 对象来处理前进和后退按钮的点击事件：\n\n```javascript\n// 监听前进和后退按钮的点击事件\nwindow.addEventListener(\'popstate\', function(e) {\n  const currentState = History.getCurrentState();\n  const previousState = History.getPrevState();\n\n  // 根据前进和后退按钮的点击判断是否需要更新应用状态\n  if (currentState && previousState && currentState.id !== previousState.id) {\n    console.log(\'Navigating from \' + previousState.url + \' to \' + currentState.url);\n\n    // 根据当前状态对象执行其他操作，例如更新页面内容等\n    // ...\n  }\n});\n\n// 在页面加载时添加初始历史状态对象\nHistory.addState({\n  url: window.location.href\n}, document.title);\n\n// 在点击前进和后退按钮时，使用 updateState() 方法更新历史状态对象\ndocument.getElementById(\'button_back\').addEventListener(\'click\', function(e) {\n  e.preventDefault();\n  History.updateState({\n    data: {},\n    url: \'/previous-page\'\n  }, true);\n});\n\ndocument.getElementById(\'button_forward\').addEventListener(\'click\', function(e) {\n  e.preventDefault();\n  History.updateState({\n    data: {},\n    url: \'/next-page\'\n  }, true);\n});\n```\n\n在这个示例中，我们首先监听浏览器的前进和后退按钮的 `popstate` 事件，以便在用户点击这些按钮时跟踪历史状态对象的变化。当历史状态对象发生变化时，我们可以利用 `getCurrentState()` 和 `getPrevState()` 方法来检索当前和上一个历史状态对象，并根据需要执行其他操作，例如更新页面内容等。\n\n我们还在页面加载时使用 `addState()` 方法添加了初始历史状态对象，并在单击前进和后退按钮时使用 `updateState()` 方法更新历史状态对象。请注意，我们将 `replace` 参数设置为 `true`，以便在更新历史状态对象时使用浏览器的 `replaceState()` 方法，这将替换当前的历史状态对象而不是新增一个历史状态对象。\n\n这只是一个简单的示例，您可以根据自己的应用程序需要进行适当的调整和修改。\n\n### Q：如何判断路由前进还是后退\n\n### A：在 `popstate` 事件中，如果通过用户点击浏览器的前进或后退按钮触发，则可以通过比较当前页面的历史状态列表（`history.state`）和 `event.state` 的异同来判断是前进还是后退，也可以通过比较历史状态列表的长度来判断是前进还是后退。以下是代码示例：\n\n```javascript\nwindow.addEventListener(\'popstate\', function(event) {\n  if (history.state === null) {\n    // 当 history.state 为空时，说明是在根页面\n    console.log(\'进入了根页面\');\n  } else if (history.state < event.state) {\n    // 当 event.state 大于 history.state 时，说明是向前进了\n    console.log(\'前进到了新页面\');\n  } else if (history.state > event.state) {\n    // 当 event.state 小于 history.state 时，说明是回退了\n    console.log(\'回到了之前的页面\');\n  }\n  // 更新 history.state\n  history.replaceState(event.state, \'\');\n});\n```\n\n在这个示例中，我们首先判断 `history.state` 是否为 null，如果是，则说明当前为根页面；否则，我们比较 `history.state` 和 `event.state` 的值的大小关系，来判断是前进还是后退。最后，我们通过 `history.replaceState()` 方法来更新 `history.state`，以便在下一次监听 `popstate` 事件时使用。\n\n需要注意的是，在实际应用中，浏览器的兼容性和性能问题需要特别注意，同时考虑到浏览器的限制和安全性等问题。例如，在一些需要进行用户身份认证、数据修改等操作的页面，需要进行特殊处理和授权操作，以避免信息泄露或者误操作等风险。',
    storage_type: '1',
    selected: 0,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 818,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
  {
    id: 55,
    time_str: '2023-04-27T06:49:59.000Z',
    last_edit_time: '2023-12-22T07:13:00.000Z',
    img_id: '',
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '前端',
    classify_id: '1',
    classify_sub: 'react',
    classify_sub_id: '1_5',
    title: '初始化react-router-dom v6',
    desc: '使用react-router-dom v6初始化项目路由',
    content:
      "## 安装react-router-dom\n```shell\nyarn add react-router-dom\n```\n## 在src下新建routes目录\n```shell\nroutes\n\t——index.tsx  \t\t\t// 最终的路由文件\n  ——routes.tsx \t\t\t// 自定义路由\n  ——routerViews.ts  // 对路由表做权限过滤数据格式转化等操作\n  ——RenderRoutes.tsx\t\t// 渲染路由结构\n```\n### routes.tsx文件\n可以根据项目需求调整数据结构\n```typescript\nimport React, { ReactNode } from 'react'\nimport {Navigate} from 'react-router-dom'\nimport PCLayout from '@/layout/PC-layout'\nimport MLayout from '@/layout/Mobile-layout'\nimport PCHome from '@pages/home/pc'\nimport MHome from '@pages/home/mobile'\n\ntype RouterListItem = {\n  title?: string\n  path: string\n  icon?: string\n  element?: ReactNode\n  auth?: string\n  children?: RouterListItem[]\n}\n\nconst routerList: RouterListItem[] = [\n  {\n    path: '/*',\n    // auth: 'getHome@auth',\n    element: <PCLayout />,\n    children: [\n      {path: '', element: <Navigate to='home' />},\n      {\n        title: '数据面板',\n        path: 'home',\n        element: <PCHome />\n          }\n    ]\n  },\n  {\n    path: '/m/*',\n    // auth: 'getHome@auth',\n    element: <MLayout />,\n    children: [\n      {path: '', element: <Navigate to='home' />},\n      {\n        title: '数据面板',\n        path: 'home',\n        element: <MHome />\n          }\n    ]\n  },\n]\n\nexport default routerList\n```\n### routerViews文件\n对路由表做权限过滤等操作，最后抛出正确的路由结构\n```typescript\nimport type { RouteObject } from \"react-router-dom\";\nimport { authRouterFilter } from '@utils/routerUtils';\nimport routes from './routes'\n\nexport const routerViews: RouteObject[] = authRouterFilter(routes);\n```\n### **RenderRoutes**文件\n根据路由表，渲染路由dom\n```typescript\nimport React from \"react\";\nimport { Route, Routes } from \"react-router-dom\";\nimport { routerViews } from \"./routerViews\";\n\n// 写法一\n// const RenderRoutes = () => {\n//   const randerRouter = (item) => {\n//     if (Array.isArray(item.children)) {\n//       return (\n//         <Route key={item?.path} path={item?.path} element={item?.element}>\n//           {item.children?.map((v) => randerRouter(v))}\n//         </Route>\n//       );\n//     } else {\n//       return (\n//         <Route key={item?.path} path={item?.path} element={item?.element} />\n//       );\n//     }\n//   };\n//   return <Routes>{routerViews?.map((v) => randerRouter(v))}</Routes>;\n// };\n\n// 写法二\nconst RenderRoutes = () => {\n  return useRoutes(routerViews);\n};\n\nexport default RenderRoutes;\n```\n### index文件\n```typescript\nimport React from 'react'\nimport { BrowserRouter } from \"react-router-dom\";\nimport RenderRoutes from './RenderRoutes'\n\nconst Router = () => {\n  return (\n    <BrowserRouter>\n      <RenderRoutes />\n    </BrowserRouter>\n  )\n}\n\nexport default Router\n```\n## 在App.tsx内引入路由\n```typescript\nimport React from \"react\";\nimport Routes from '@/routes'\n\nconst App = () => {\n  return <Routes />;\n};\n\nexport default App;\n```\n\n**以上就是如何使用react-router-dom初始化路由结构**\n\n## v6版本相对于之前的变化\n### Route 路径的变化\n\n- 占位符 * 和 :id可以用，正则不能用了\n- v6中的所有路径匹配都将忽略URL上的尾部\"/\"\n### Switch 重命名为 Routes\n### Route 的 component 变成了 element\n### Outlet 渲染子路由\n用来渲染子路由，替换之前的 props.children\n### 去掉了 useHistory\n用 useNavigate 作为替代，页面跳转写法改变\n```typescript\n// 原\nimport { useHistory } from 'react-router-dom';\n...\nconst history = useHistory()\nhistory.push('/index1')\nhistory.replace('/index2')\n...\n\n\n// v6\nimport { useNavigate } from 'react-router-dom';\n...\nconst navigate = useNavigate();\nnavigate('/index1')\nnavigate('/index2', {replace: true})\n...\n```\n### Redirect 重命名为 Navigate\n### 新增了 useRoutes，\n可以替代 react-router-config\n```typescript\nconst routes = {\n    path: '/',\n    element: <SecurityLayout />,\n    children: [\n        { path: '', element: <Navigate to=\"/user/login\" /> }, // Redirect 重定向！\n        {\n            path: '',\n            element: <BasicLayout />,\n            children: [\n                // BasicLayout 业务页面\n                {\n                    path: 'index1',\n                    element: <Index1/>\n                },\n                {\n                    path: 'index2',\n                    element: <Index2/>\n                },\n            ]\n        },\n    ]\n}\nfunction RenderRoutes() {\n    const element = useRoutes(routes)\n    return element;\n}\n```\n",
    storage_type: '1',
    selected: 0,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 875,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
  {
    id: 54,
    time_str: '2023-04-23T03:12:30.000Z',
    last_edit_time: '2023-04-24T02:18:27.000Z',
    img_id: '',
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '前端',
    classify_id: '1',
    classify_sub: '其它',
    classify_sub_id: '1_16',
    title: 'VSCode的ESLint和项目的ESLint冲突',
    desc: 'VSCode的ESLint和项目的ESLint冲突',
    content:
      '**当 VS Code 和项目中的 ESLint 冲突时，可以尝试以下方法解决：**\n## 在项目中安装 ESLint 插件：\n```shell\nnpm install eslint --save-dev\n```\n## 在 VS Code 中安装 ESLint 插件。\n## 在 VS Code 中配置 ESLint\n在 VS Code 中配置 ESLint，可以在 VS Code 的设置中搜索 **eslint**，找到 **ESLint: Options** 选项，然后添加下面的配置：(也可以在 **.vscode/settings.json** 下配置)\n```json\n{\n  "eslint.enable": true,\n  "eslint.options": {\n    "configFile": ".eslintrc.js"\n  }\n}\n```\n**注意：上述配置中的 .eslintrc.js 应该是你项目中真正的 ESLint 配置文件的路径。**\n## 创建 .vscode/extensions.json 文件\n在项目的根目录下创建 .vscode/extensions.json 文件，并添加以下配置：\n```json\n{\n  "recommendations": [\n    "dbaeumer.vscode-eslint"\n  ]\n}\n```\n**注意：上述配置中的 dbaeumer.vscode-eslint 是 ESLint 扩展的 ID，表示在 VS Code 中推荐安装该扩展。如果已经安装了该扩展，则可以省略该配置。**\n## 重新启动 VS Code\n重新启动 VS Code，尝试在编辑器中打开一个 JavaScript 或 TypeScript 文件，并执行格式化操作，看看是否仍然会出现 ESLint 错误。如果还有错误，可以尝试重新安装和配置 ESLint 插件，并根据需要修改项目中的 ESLint 配置文件。\n',
    storage_type: '1',
    selected: 0,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 861,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
  {
    id: 53,
    time_str: '2023-04-14T16:27:13.000Z',
    last_edit_time: '2023-12-22T07:25:00.000Z',
    img_id: '',
    author_id: '3bbb83cf287c50c2ead0b0275842f33f',
    classify: '前端',
    classify_id: '1',
    classify_sub: '其它',
    classify_sub_id: '1_16',
    title: '服务端渲染-Next.js',
    desc: '服务端渲染-Next.js',
    content:
      '## 服务端渲染-Next.js\n>之前有分享过服务端渲染的一些知识，本周继续就服务端渲染进行分享，对于NextJs我也是初次接触，有不正确的地方欢迎大家指正。[_服务端渲染初识_](https://tet5mctqdj.feishu.cn/wiki/wikcnKBiqpElyPCZtHAOibau8Hg)\n\n### Next.js\nDome: [GitHub - wp0403/next-blog-client](https://github.com/wp0403/next-blog-client.git)\n\n### 初始化项目\n```javascript\nBashnpx create-next-app@latest --typescript\n# or\nyarn create next-app --typescript\n# or\npnpm create next-app --typescript\n```\n### 启动项目\n```javascript\n"scripts": {\n    "dev": "next dev -p 6006",\n    "build": "next build",\n    "start": "next start -p 6006",\n    "lint": "next lint",\n    "server": "next build && next start -p 6006"\n},\n```\n### 目录结构\n```javascript\nTypeScript.next  // 打包目录\ncomponents    // 公用组件\n    Footer\n    Layout\n    Navbar\n    ...\nnode_modules  // npm包\npages  // 页面\n    api   // api目录\n    _app.tsx // 全局处理\n    index // 首页\n    ...\npublic // 静态文件\nstyles // css样式表\nutils  // 工具函数集\nnext.config.js // next配置文件\npackage.json\n...\n```\n### 配置next/image的远程模式\n文档：[next/image | Next.js](https://nextjs.org/docs/api-reference/next/image)\n```javascript\nTypeScript/** @type {import(\'next\').NextConfig} */\nconst nextConfig = {\n  reactStrictMode: true,\n  swcMinify: true,\n\n  images: {\n    remotePatterns: [\n      {\n        protocol: \'https\',\n        hostname: \'**.myqcloud.com\',\n      },\n    ],\n  },\n}\n\nmodule.exports = nextConfig\n```\n### 切换路由时添加加载动画\npages/_app.tsx<br />通过监听路由事件，为next添加页面过渡动画\n```javascript\nTypeScriptimport Router from "next/router";\nimport type { AppProps } from "next/app";\nimport { useEffect, useState } from "react";\nimport Layout from "../components/Layout";\nimport PageLoading from "../components/PageLoading";\nimport "../styles/globals.css";\n\nexport default function App({ Component, pageProps }: AppProps) {\n  const routeChangeComplete = () => {\n    (document.getElementById("__next") || window).scrollTo(0, 0);\n  };\n\n  const [loading, setLoading] = useState<boolean>(false);\n\n  useEffect(() => {\n    Router.events.on("routeChangeComplete", routeChangeComplete);\n    Router.events.on("routeChangeStart", () => {\n      setLoading(true);\n    });\n    Router.events.on("routeChangeComplete", () => {\n      setLoading(false);\n    });\n    Router.events.on("routeChangeError", () => {\n      setLoading(false);\n    });\n\n    return () => {\n      Router.events.off("routeChangeComplete", routeChangeComplete);\n    };\n  }, []);\n  return (\n    <Layout>{loading ? <PageLoading /> : <Component {...pageProps} />}</Layout>\n  );\n}\n```\n### 实现动态路由 getStaticPaths\nfallback: [https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-false](https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-false)\n```javascript\nTypeScriptexport async function getStaticPaths() {\n  // 调用外部 API 获取内容\n  const res = await fetch(`https://wp-boke.work/api/getClassifyListPage`);\n  const posts = await res.json();\n\n  const arr = [] as string[];\n  for (let i = 1; i <= posts.data; i++) {\n    arr.push(i.toString());\n  }\n\n  return {\n    // 必须叫paths，值必须是数组\n    paths: arr.map((v) => ({ params: { page: v } })),\n    // https://nextjs.org/docs/api-reference/data-fetching/get-static-paths#fallback-false\n    fallback: \'blocking\',  // true false \'blocking\'\n  };\n}\n```\n### 设置缓存失效\ngetStaticProps生成静态页面后，可以添加revalidate设置页面缓存的时间，过期后，下次请求将重新生成页面数据\n```javascript\nTypeScriptexport async function getStaticProps({ params }) {\n  // params contains the post `id`.\n  // If the route is like /posts/1, then params.id is 1\n  const res = await fetch(\n    `https://wp-boke.work/api/getClassifyDetails?id=${params.blogID}`\n  );\n  const posts = await res.json();\n\n  // Pass post data to the page via props\n  return { \n    props: { posts },    \n    revalidate: 60, // In seconds \n  };\n}\n```\n',
    storage_type: '1',
    selected: 0,
    isDelete: 0,
    type: 1,
    storage_desc: 'Markdown',
    views: 901,
    likes: 0,
    userInfo: {
      id: '3bbb83cf287c50c2ead0b0275842f33f',
      name: 'Shimmer',
    },
  },
];

export const classifyNum = {
  classifyNum: [
    {
      type: '1',
      label: '前端',
      count: 21,
    },
    {
      type: '5',
      label: '阳光自在',
      count: 1,
    },
    {
      type: '3',
      label: '其它学习资料',
      count: 1,
    },
  ],
  classifySubNum: [
    {
      type: '1_16',
      label: '其它',
      count: 11,
    },
    {
      type: '1_13',
      label: 'npm',
      count: 2,
    },
    {
      type: '5_1',
      label: '生活',
      count: 1,
    },
    {
      type: '3_2',
      label: 'git',
      count: 1,
    },
    {
      type: '1_10',
      label: 'echarts',
      count: 2,
    },
    {
      type: '1_3',
      label: 'javaScript',
      count: 3,
    },
    {
      type: '1_5',
      label: 'react',
      count: 2,
    },
    {
      type: '1_4',
      label: 'vue3',
      count: 1,
    },
  ],
};

export const totalPage = 3;

export const pageList = ['1', '2', '3'];
